/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/assets/data/levels.js":
/*!***********************************!*\
  !*** ./src/assets/data/levels.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"levels\": () => (/* binding */ levels)\n/* harmony export */ });\nconst levels = [\n    {\n        \"id\": 0,\n        \"sheep\": 15,\n        \"time\": 30,\n        \"level_url\": \"level1.png\",\n        \"obstacles\": [\n            {\n                \"x\": 269,\n                \"y\": 213,\n                \"width\": 69, \n                \"height\": 84\n            },\n        ]\n    },\n    {\n        \"id\": 1,\n        \"sheep\": 20,\n        \"time\": 40,\n        \"level_url\": \"level2.png\",\n        \"obstacles\": [\n            {\n                \"x\": 96,\n                \"y\": 21,\n                \"width\": 65, \n                \"height\": 80\n            },\n            {\n                \"x\": 240,\n                \"y\": 22,\n                \"width\": 64, \n                \"height\": 79\n            },\n            {\n                \"x\": 124,\n                \"y\": 262,\n                \"width\": 67, \n                \"height\": 78\n            },\n            {\n                \"x\": 280,\n                \"y\": 360,\n                \"width\": 67, \n                \"height\": 82\n            },\n        ]\n    },\n    {\n        \"id\": 2,\n        \"sheep\": 30,\n        \"time\": 30,\n        \"level_url\": \"level3.png\",\n        \"obstacles\": [\n            {\n                \"x\": 179,\n                \"y\": 87,\n                \"width\": 92, \n                \"height\": 18\n            },\n            {\n                \"x\": 97,\n                \"y\": 155,\n                \"width\": 88, \n                \"height\": 15\n            },\n            {\n                \"x\": 91,\n                \"y\": 252,\n                \"width\": 66, \n                \"height\": 79\n            },\n            {\n                \"x\": 234,\n                \"y\": 252,\n                \"width\": 65, \n                \"height\": 79\n            },\n        ]\n    }\n];\n\n//# sourceURL=webpack://doggone-it/./src/assets/data/levels.js?");

/***/ }),

/***/ "./src/assets/js/action_replay.js":
/*!****************************************!*\
  !*** ./src/assets/js/action_replay.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ActionReplay\": () => (/* binding */ ActionReplay),\n/* harmony export */   \"ReplaySpeed\": () => (/* binding */ ReplaySpeed)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/assets/js/constants.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities.js */ \"./src/assets/js/utilities.js\");\n/* harmony import */ var _frame_drawer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./frame_drawer.js */ \"./src/assets/js/frame_drawer.js\");\n\n\n\n\n/**\n * An enum representing the speed at which the replay is being played\n */\nconst ReplaySpeed = {\n    NORMAL: 1,\n    PAUSE: 0,\n    FAST_FORWARD: 2,\n    REWIND: -2\n};\n\n/**\n * A class that represents an action replay of the level just played.\n */\nclass ActionReplay {\n    constructor(snapshots, graphics, level) {\n        this.snapshots = snapshots;\n        this.graphics = graphics;\n        this.level = level;\n\n        this.snapshotIndex = 0;\n        this.frameCount = 0;\n        this.replaySpeed = ReplaySpeed.FAST_FORWARD;\n\n        this.drawBackground();\n        this.drawReplayFrame(snapshots[0]);\n\n        // Calibrate the replay slider's value scale.\n        let replaySlider = document.getElementById(\"replay-slider\");\n        replaySlider.max = this.snapshots.length - 1;\n    }\n\n    update() {\n        // Only update every REPLAY_SNAPSHOT_FREQUENCY frames\n        if (++this.frameCount % _constants_js__WEBPACK_IMPORTED_MODULE_0__.REPLAY_SNAPSHOT_FREQUENCY === 0) {\n            \n            // Increment the index of the snapshot (which points to \n            // the correct snapshot in the array). Prevent it from running\n            // off either end of the array\n            this.snapshotIndex += this.replaySpeed;\n            if (this.snapshotIndex <= 0) {\n                this.snapshotIndex = 0;\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.show)([\"play\"]);\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.hide)([\"pause\"]);\n                this.replaySpeed = ReplaySpeed.PAUSE;\n            } else if (this.snapshotIndex >= this.snapshots.length) {\n                this.snapshotIndex = this.snapshots.length - 1;\n            }\n\n            // Draw this snapshot\n            this.drawBackground();\n            this.drawReplayFrame(this.snapshots[this.snapshotIndex]);\n\n            // Update the replay-time slider\n            let replaySlider = document.getElementById(\"replay-slider\");\n            replaySlider.value = this.snapshotIndex;\n\n            // Update the time-display.\n            let timeDisplay = document.getElementById(\"replay-time\");\n            let framesPerSecond = 60 / _constants_js__WEBPACK_IMPORTED_MODULE_0__.REPLAY_SNAPSHOT_FREQUENCY;\n            let seconds = this.snapshotIndex / framesPerSecond;\n            let hundreths = (seconds % 1) * 100;\n            let sText = Math.floor(seconds).toLocaleString(\"en-UK\", {\n                minimumIntegerDigits: 2\n            });\n            let hText = Math.floor(hundreths).toLocaleString(\"en-UK\", {\n                minimumIntegerDigits: 2\n            });\n            timeDisplay.innerText = `${sText}.${hText}`;\n            \n        }\n\n        // Flash the replay banner on and off twice a second\n        if (this.frameCount % 30 === 0) {\n            let replayBanner = document.getElementById(\"replay-banner\");\n            if (replayBanner.style.display === \"none\") {\n                replayBanner.style.display = \"initial\";\n            } else {\n                replayBanner.style.display = \"none\";\n            }\n        }\n\n    }\n\n    /**\n     * Draws one snapshot frame of the previous level\n     * @param {Snapshot} snapshot \n     */\n    drawReplayFrame (snapshot) {\n\n        let canvas = document.getElementById(\"game-area\");\n        if (canvas) {\n            document.getElementById(\"sheep-remaining\").innerText = snapshot.sheep.length;\n            let context = canvas.getContext(\"2d\");\n\n            // Pick the correct directional sprite from South, West, North, East\n            let quadrant = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.getQuadrant)(snapshot.dog.direction);\n            let [index, adjustedAngle] = (0,_frame_drawer_js__WEBPACK_IMPORTED_MODULE_2__.getIndexAndAdjustedAngle)(\n                quadrant,\n                snapshot.dog.direction);\n            let correctSprite = this.graphics.dog.images[index];\n            \n            // Draw the dog.\n            (0,_frame_drawer_js__WEBPACK_IMPORTED_MODULE_2__.drawSprite)(\n                context,\n                correctSprite,\n                Math.floor(snapshot.dog.x),\n                Math.floor(snapshot.dog.y),\n                adjustedAngle,\n                0.8);\n\n            // Draw the herd\n            for (let i = 0; i < snapshot.sheep.length; i++) {\n                let sheep = snapshot.sheep[i];\n\n                // Pick the correct directional sprite from South, West, North, East\n                let quadrant = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.getQuadrant)(sheep.direction);\n                let [index, adjustedAngle] = (0,_frame_drawer_js__WEBPACK_IMPORTED_MODULE_2__.getIndexAndAdjustedAngle)(quadrant, sheep.direction);\n                let correctSprite = this.graphics.sheep.images[index];\n                let scale = sheep.isLamb ? 0.7 : 1.0;\n\n                // Draw this sheep\n                (0,_frame_drawer_js__WEBPACK_IMPORTED_MODULE_2__.drawSprite)(\n                    context,\n                    correctSprite,\n                    sheep.x,\n                    sheep.y,\n                    adjustedAngle,\n                    scale\n                );\n            }\n        }\n    }\n\n    /**\n     * Draws the background image onto the canvas in order to clear it\n     */\n    drawBackground() {\n        let gameCanvas = document.getElementById('game-area');\n            let context = gameCanvas.getContext('2d');\n            context.drawImage(this.graphics.backgrounds.images[this.level.id], 0, 0);\n        }\n}\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/action_replay.js?");

/***/ }),

/***/ "./src/assets/js/constants.js":
/*!************************************!*\
  !*** ./src/assets/js/constants.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOG_SLOWDOWN_RANGE\": () => (/* binding */ DOG_SLOWDOWN_RANGE),\n/* harmony export */   \"DOG_UNIT_MOVE\": () => (/* binding */ DOG_UNIT_MOVE),\n/* harmony export */   \"FIELD_BORDER\": () => (/* binding */ FIELD_BORDER),\n/* harmony export */   \"FIELD_HEIGHT\": () => (/* binding */ FIELD_HEIGHT),\n/* harmony export */   \"FIELD_WIDTH\": () => (/* binding */ FIELD_WIDTH),\n/* harmony export */   \"REPLAY_SNAPSHOT_FREQUENCY\": () => (/* binding */ REPLAY_SNAPSHOT_FREQUENCY),\n/* harmony export */   \"SHEEP_BASE_VELOCITY_AWAY_FROM_DOG\": () => (/* binding */ SHEEP_BASE_VELOCITY_AWAY_FROM_DOG),\n/* harmony export */   \"SHEEP_MAX_VELOCITY_AWAY_FROM_DOG\": () => (/* binding */ SHEEP_MAX_VELOCITY_AWAY_FROM_DOG),\n/* harmony export */   \"SHEEP_MIN_DISTANCE_FROM_HERD\": () => (/* binding */ SHEEP_MIN_DISTANCE_FROM_HERD),\n/* harmony export */   \"SHEEP_OUTER_REACTION_LIMIT\": () => (/* binding */ SHEEP_OUTER_REACTION_LIMIT),\n/* harmony export */   \"SHEEP_VELOCITY_TOWARDS_HERD\": () => (/* binding */ SHEEP_VELOCITY_TOWARDS_HERD),\n/* harmony export */   \"SIDE_REPULSION_DISTANCE\": () => (/* binding */ SIDE_REPULSION_DISTANCE)\n/* harmony export */ });\n/**\n * Represents the base speed a sheep will travel\n * at in the direction of the center of its neighbours.\n */\nconst SHEEP_VELOCITY_TOWARDS_HERD = 1.5;\n\n\n/**\n * Represents the base speed (when least anxious) a sheep will travel \n * at away from the dog.\n */\nconst SHEEP_BASE_VELOCITY_AWAY_FROM_DOG = 1;\n\n\n/**\n * Represents the fastest a sheep is able to move away from the dog.\n */\nconst SHEEP_MAX_VELOCITY_AWAY_FROM_DOG = 6;\n\n/**\n * Represents the range inside which the dog needs to be in order\n * for the sheep to react.\n */\nconst SHEEP_OUTER_REACTION_LIMIT = 150;\n\n\n/**\n * Represents the distance within which the sheep are repelled by\n * corners. Without this, they have a tendency to get herded into\n * the corners and get stuck.\n */\nconst SIDE_REPULSION_DISTANCE = 50;\n\n\n/**\n * Represents the distance closer than which a sheep is no longer\n * attracted to the herd.\n */\nconst SHEEP_MIN_DISTANCE_FROM_HERD = 120;\n\n\n/**\n * Represents the distance the dog can travel in one frame\n */\nconst DOG_UNIT_MOVE = 2.5;\n\n\n/**\n * Represents the distance at which the dog will start to\n * slow down when approaching his destination.\n */\nconst DOG_SLOWDOWN_RANGE = 25;\n\n\n/**\n * The width of the internal model field used by the game.\n */\nconst FIELD_WIDTH = 400;\n\n\n/**\n * The height of the internal model field used by the game.\n */\nconst FIELD_HEIGHT = 500;\n\n\n/**\n * The border around the edge of the field beyond which the \n * game characters cannot go.\n */\nconst FIELD_BORDER = 30;\n\n\n/**\n * The number of frames between snaphots of the game recorded \n * for action replay.\n */\nconst REPLAY_SNAPSHOT_FREQUENCY = 1;\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/constants.js?");

/***/ }),

/***/ "./src/assets/js/dog.js":
/*!******************************!*\
  !*** ./src/assets/js/dog.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dog\": () => (/* binding */ Dog)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/assets/js/utilities.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./src/assets/js/constants.js\");\n\n\n\n\nclass Dog {\n    /**\n     * A class representing a dog\n     * @param {Number} xPos The x-coordinate of the dog's position \n     * @param {Number} yPos The y-coordinate of the dog's position \n     */\n    constructor(xPos, yPos, obstacles) {\n        this.xPos = xPos;\n        this.yPos = yPos;\n        this.xDest = xPos;\n        this.yDest = yPos;\n        this.direction = 0;\n        this.unitMove = _constants_js__WEBPACK_IMPORTED_MODULE_1__.DOG_UNIT_MOVE;\n        this.moving = false;\n        this.pointerDown = false;\n        this.wayPoints = [];\n        this.obstacleArray = [];\n        for (let ob of obstacles) {\n            let rectangle = new _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Rectangle(ob.x, \n                                          ob.y, \n                                          ob.x + ob.width,\n                                          ob.y + ob.height);\n            this.obstacleArray.push(rectangle);\n        }\n        \n    }\n\n    /**\n     * Updates the dog's position, called before each repaint\n     */\n    update() {\n        this.moveToDest();\n    }\n\n    /**\n     * Moves the dog in the direction of its destination. \n     */\n    moveToDest() {\n\n        // If the wayPoints array is not empty, assign wayPoints[0] as the\n        // next destination.\n        if (this.wayPoints.length > 0) {\n            [this.xDest, this.yDest] = this.wayPoints[0];\n            this.moving = true;\n        }\n\n        // Check if the dog has arrived at the next waypoint. If so, remove the\n        // waypoint. If there are no more waypoints, return immediately.\n        if (this.arrivedAtNextWaypoint()) {\n            this.wayPoints.shift();\n            if (!this.hasNextWaypoint()) {\n                this.moving = false;\n                return;\n            } else {\n                this.assignNextDestination();\n                this.moving = true;\n            }\n        }\n\n        this.turnTowardsDestination();\n\n        // Reduce the dogs speed as he nears his final wayPoint. \n        let distToDestination = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.getDistanceToPoint)(this.xPos, this.yPos, this.xDest, this.yDest);\n        let distToTravel = this.unitMove;\n        if (distToDestination < _constants_js__WEBPACK_IMPORTED_MODULE_1__.DOG_SLOWDOWN_RANGE && this.wayPoints.length === 1) {\n            distToTravel *= distToDestination / _constants_js__WEBPACK_IMPORTED_MODULE_1__.DOG_SLOWDOWN_RANGE;\n        }\n\n        let xVel = distToTravel * Math.cos(this.direction);\n        let yVel = distToTravel * Math.sin(this.direction);\n\n        // Ensure the calculated move will not result in the dog entering\n        // any of the obstacles in this level\n        [xVel, yVel] = this.checkMoveForObstacles(\n            xVel,\n            yVel,\n            this.obstacles);\n        \n        // Finally, update the dogs position.\n        this.xPos += xVel;\n        this.yPos += yVel;\n    }\n\n    /**\n     * If the pointerDown flag is false, sets it to true and clears\n     * the wayPoints array, as this is the beginning of a new path for\n     * the dog.\n     * @param {Number} x \n     * @param {Number} y \n     */\n    onPointerDown(x, y) {\n        if (!this.pointerDown) {\n            this.pointerDown = true;\n            this.wayPoints = [];\n        }\n    }\n\n    /**\n     * Adds the current pointer position to the end of the wayPoints array\n     * @param {Number} x \n     * @param {Number} y \n     */\n    onPointerMove(x, y) {\n        if (this.pointerDown && this.checkWaypointIsValid(x, y, this.obstacleArray)) {\n            this.wayPoints.push([x, y]);\n        }\n    }\n\n    /**\n     * Sets the pointerDown flag to false, and adds the supplied point\n     * to the wayPoints array. This also ensures that a pointer tap/click\n     * without dragging will result in at least this one wayPoint\n     * @param {Number} x \n     * @param {Number} y \n     */\n    onPointerUp(x, y) {\n        this.pointerDown = false;\n        if (this.checkWaypointIsValid(x, y, this.obstacleArray)) {\n            this.wayPoints.push([x, y]);\n        } \n    }\n\n    /**\n     * Makes the dog turn towards its destination\n     */\n    turnTowardsDestination() {\n        // Calculate the direction the dog needs to travel in to head directly for\n        // its destination, and turn towards this direction.\n        let correctDirection = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.getDirectionToPoint)(\n            this.xPos,\n            this.yPos,\n            this.xDest,\n            this.yDest);\n        this.direction = correctDirection;\n    }\n\n    /**\n     * @returns true if distance is less than an effective threshold, false otherwise.\n     */\n    arrivedAtNextWaypoint() {\n        let distToNextWaypoint = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.getDistanceToPoint)(this.xDest, this.yDest, this.xPos, this.yPos);\n        return distToNextWaypoint <= this.unitMove * 2;\n    }\n\n    /**\n     * \n     * @returns true if the destination array has at least one element.\n     */\n    hasNextWaypoint() {\n        return this.wayPoints.length > 0;\n    }\n\n    /**\n     * Assigns the last element in the destinations array as the current destination.\n     */\n    assignNextDestination() {\n        this.xDest = this.wayPoints[0][0];\n        this.yDest = this.wayPoints[0][1];\n    }\n\n    /**\n     * Ensures that the dog does not enter an area of the level occupied by \n     * an obstacle.\n     * @param {Number} xVel The x velocity calculated for the current move\n     * @param {Number} yVel The y velocity calculated for the current move\n     * @returns the x and y velocities adjusted to avoid entering an obstacle\n     */\n     checkMoveForObstacles(xVel, yVel) {\n        let futureX = this.xPos + xVel;\n        let futureY = this.yPos + yVel;\n        for (let obstacle of this.obstacleArray) {\n            if ((0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.rectContainsPoint)(obstacle, new _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Point(futureX, futureY))) {\n                // Try keeping the current xPosition unchanged\n                if (!(0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.rectContainsPoint)(obstacle, new _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Point(this.xPos, futureY))) {\n                    return [0, yVel];\n                }\n                // If that doesn't work, try keeping the current yPosition unchanged\n                if (!(0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.rectContainsPoint)(obstacle, new _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Point(futureX, this.yPos))) {\n                    return [yVel, 0];\n                }\n                // Last resort, keep both unchanged\n                return [0, 0];\n\n            }\n        }\n        return [xVel, yVel];\n    }\n\n    /**\n     * Checks that a potential waypoint does not overlap with any of the obstacles\n     * in this level, and also that it falls within the borders of the game area,\n     * including the fences.\n     * @param {*} x \n     * @param {*} y \n     * @param {*} obstacleArray \n     * @returns true if waypoint is valid, false otherwise\n     */\n    checkWaypointIsValid(x, y, obstacleArray) {\n        // Check if the point is within any of the obstacles\n        for (let ob of obstacleArray) {\n            if ((0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.rectContainsPoint)(ob, new _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Point(x, y))) {\n                return false;\n            }\n        }\n\n        // Check that the point is within the fences on the game area\n        if (x < _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_BORDER || x > _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_WIDTH - _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_BORDER || \n            y < _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_BORDER || y > _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_HEIGHT - _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_BORDER) {\n                return false;\n        }\n\n        // Point is valid - return true\n        return true;\n    }\n\n    /**\n     * Attaches an event (change) listener to the dog-speed slider in settings, \n     * to enable the player to experiment with different values for the \n     * unitMove variable\n     */\n    setSliderEventListener() {\n        let slider = document.getElementById(\"dog-speed\");\n\n        // As well as attaching the listener, read the current value\n        // and set the unitMove variable accordingly.\n        this.unitMove = _constants_js__WEBPACK_IMPORTED_MODULE_1__.DOG_UNIT_MOVE * slider.value;\n\n        // Attach the listener\n        slider.addEventListener('change', () => {\n            this.unitMove = _constants_js__WEBPACK_IMPORTED_MODULE_1__.DOG_UNIT_MOVE * slider.value;\n        });\n    }\n}\n\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/dog.js?");

/***/ }),

/***/ "./src/assets/js/frame_drawer.js":
/*!***************************************!*\
  !*** ./src/assets/js/frame_drawer.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawFrame\": () => (/* binding */ drawFrame),\n/* harmony export */   \"drawSprite\": () => (/* binding */ drawSprite),\n/* harmony export */   \"getIndexAndAdjustedAngle\": () => (/* binding */ getIndexAndAdjustedAngle)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/assets/js/utilities.js\");\n\n\n/**\n * Draws a single frame of the game.\n * \n * @param {Dog} dog \n * @param {Herd} herd \n * @param {Integer} frameCount \n * @param {Object} sprites \n */\nconst drawFrame = (dog, herd, frameCount, sprites) => {\n    let gameCanvas = document.getElementById('game-area');\n    let context;\n    if (gameCanvas) {\n        context = gameCanvas.getContext('2d');\n    }\n\n    // If the pointer is down, draw the dog's path\n    if (dog.wayPoints.length > 0 && dog.pointerDown) {\n        context.strokeStyle = 'white';\n        context.lineWidth = 5;\n        context.beginPath();\n        context.moveTo(dog.xPos, dog.yPos);\n        for (let i = 0; i < dog.wayPoints.length; i++) {\n            context.lineTo(\n                dog.wayPoints[i][0],\n                dog.wayPoints[i][1]);\n        }\n        context.stroke();\n    }\n\n    // Pick the correct directional dog sprite from South, West, North, East\n    let quadrant = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.getQuadrant)(dog.direction);\n    let [index, adjustedAngle] = getIndexAndAdjustedAngle(quadrant, dog.direction);\n\n    // Pick the correct sprite leg position based on the frame count\n    let indexOffset;\n    if (!dog.moving) {\n        indexOffset = 2;\n    } else {\n        indexOffset = getSpriteFrame(frameCount);\n    }\n    let correctSprite = sprites.dog.images[index + indexOffset];\n\n    // Draw the dog.\n    drawSprite(\n        context,\n        correctSprite,\n        Math.floor(dog.xPos),\n        Math.floor(dog.yPos),\n        adjustedAngle,\n        0.8);\n\n    // If the pointer is down, draw the dog's destination\n    if (dog.pointerDown) {\n        context.fillStyle = 'white';\n        context.fillRect(dog.xDest - 2, dog.yDest - 2, 5, 5);\n    }\n\n    // Draw the herd\n    for (let i = 0; i < herd.xArray.length; i++) {\n        let sheep = herd.xArray[i];\n\n        // Pick the correct directional sheep sprite from South, West, North, East\n        let quadrant = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.getQuadrant)(sheep.direction);\n        let [index, adjustedAngle] = getIndexAndAdjustedAngle(\n                                        quadrant, \n                                        sheep.direction);\n\n        // Pick the correct sprite leg position based on the frame count\n        if (!sheep.moving) {\n            indexOffset = 2;\n        } else {\n            indexOffset = getSpriteFrame(frameCount);\n        }\n        let correctSprite = sprites.sheep.images[index + indexOffset];\n\n        // Calculate the scale based on whether this sheep is a lamb or not\n        let scale = sheep.isLamb ? 0.7 : 1.0;\n\n        // Draw this sheep\n        drawSprite(\n            context,\n            correctSprite,\n            sheep.xPos,\n            sheep.yPos,\n            adjustedAngle,\n            scale\n        );\n    }\n};\n\n/**\n * Draws a sprite image on a supplied context, rotating the context so\n * as to draw the sprite pointing in the appropriate direction.\n * @param {Context} context \n * @param {Image} image \n * @param {Number} x \n * @param {Number} y \n * @param {Number} angle \n * @param {Number} scale The ratio of the drawn size to the original image size\n */\nconst drawSprite = (context, image, x, y, angle, scale) => {\n    if (image) {\n        let imgWidth = image.width * scale;\n        let imgHeight = image.height * scale;\n        context.save();\n        context.translate(x, y);\n        context.rotate(angle);\n        context.drawImage(\n            image,\n            -imgWidth / 2, -imgHeight / 2,\n            imgWidth, imgHeight);\n        context.restore();\n    }\n};\n\n/**\n * Takes the integer frameCount since the start of the game modulo 20, \n * and chooses whether the left leg of the animal should be leading, the\n * right leg should be leading, or the two legs should be together.\n * \n * This creates a walking effect by alternating the leg positions as\n * the frames progress.\n * \n * @param {Integer} frameCount \n * @returns an integer offset used to choose the correct sprite\n */\nconst getSpriteFrame = (frameCount) => {\n    let modulus = frameCount % 20;\n    if (modulus < 5) {\n        return 0;\n    } else if (modulus >= 10 && modulus < 15) {\n        return 1;\n    } else {\n        return 2;\n    }\n};\n\n/**\n * Takes a quadrant value and calculates which sprite is the correct one\n * to display. There are four different classes of sprite - one for each direction\n * of the compass.\n * \n * As these sprites do not all face in the same direction, an angle offset is \n * calculated to compensate.\n * \n * @param {Enum : Quadrant} quadrant \n * @returns index : the base index of the correct sprite\n * @returns angleOffset : the adjustment to the sprites direction.\n */\nconst getIndexAndAdjustedAngle = (quadrant, direction) => {\n    let index, adjustedAngle;\n    switch (quadrant) {\n        case _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Quadrant.SOUTH: {\n            index = 0;\n            adjustedAngle = direction - Math.PI / 2;\n            break;\n        }\n        case _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Quadrant.WEST: {\n            index = 3;\n            adjustedAngle = 0;\n            break;\n        }\n        case _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Quadrant.NORTH: {\n            index = 6;\n            adjustedAngle = direction + Math.PI / 2;\n            break;\n        }\n        case _utilities_js__WEBPACK_IMPORTED_MODULE_0__.Quadrant.EAST:\n        default: {\n            index = 9;\n            adjustedAngle = 0;\n        }\n    }\n    return [index, adjustedAngle];\n};\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/frame_drawer.js?");

/***/ }),

/***/ "./src/assets/js/game_runner.js":
/*!**************************************!*\
  !*** ./src/assets/js/game_runner.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameRunner\": () => (/* binding */ GameRunner)\n/* harmony export */ });\n/* harmony import */ var _dog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dog.js */ \"./src/assets/js/dog.js\");\n/* harmony import */ var _herd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./herd.js */ \"./src/assets/js/herd.js\");\n/* harmony import */ var _data_levels_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/levels.js */ \"./src/assets/data/levels.js\");\n/* harmony import */ var _frame_drawer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./frame_drawer.js */ \"./src/assets/js/frame_drawer.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"./src/assets/js/constants.js\");\n/* harmony import */ var _action_replay_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./action_replay.js */ \"./src/assets/js/action_replay.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utilities.js */ \"./src/assets/js/utilities.js\");\n\n\n\n\n\n\n\n\nfunction GameRunner(graphics, level) {\n    this.graphics = graphics;\n    this.level = level;\n    this.frameCount = 0;\n    this.running = false;\n    this.dog = new _dog_js__WEBPACK_IMPORTED_MODULE_0__.Dog(_constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_WIDTH / 2, \n                      _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_HEIGHT / 4,\n                      level.obstacles);\n    this.herd = new _herd_js__WEBPACK_IMPORTED_MODULE_1__.Herd(level);\n    this.awaitingGameStart = true;\n    this.levelTimeLimit = level.time * 1000;\n    this.timeRemaining = level.time * 1000;\n    this.lastStartTime = new Date().getTime();\n\n    this.actionReplay = null;\n    this.snapshots = [];\n\n    (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\"go-button\"]);\n\n    // Calibrate the time remaining display to this level's time limit.\n    document.getElementById(\"time-remaining\").max = this.levelTimeLimit;\n    document.getElementById(\"time-remaining\").value = this.levelTimeLimit;\n\n    // This is the callback passed to window.requestAnimationFrame, \n    // and needs to be explicitly bound to the GameRunner object, \n    // otherwise 'this' will refer to the window object from the \n    // requestAnimationFrame() scope.\n    this.updateGame = (function () {\n        if (++this.frameCount % 1 === 0) {\n            this.drawBackground();\n            // If an action replay exists, update it.\n            if (this.actionReplay) {\n                this.actionReplay.update();\n            } else if (this.running) {\n                this.dog.update();\n                this.herd.update(this.dog);\n                document.getElementById(\"sheep-remaining\").innerText = this.herd.xArray.length;\n\n                // Check for level complete\n                if (this.herd.allSheepGone) {\n                    if (this.level.id + 1 === _data_levels_js__WEBPACK_IMPORTED_MODULE_2__.levels.length) {\n                        // Player has finished the final level\n                        this.running = false;\n                        this.dimmerMaskOn(true);\n                        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"next-level-button\", \n                              \"go-button\",\n                              \"try-again-button\"]);\n                        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\n                            \"end-of-level-display\",\n                            \"end-level-message\",\n                        ]);\n                        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showMessage)(\"You beat the game!\");\n                    } else {\n                        this.running = false;\n                        this.dimmerMaskOn(true);\n                        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\n                            \"end-of-level-display\",\n                            \"end-level-message\",\n                            \"next-level-button\",\n                            \"action-replay-button\"]);\n                            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"go-button\",\n                                  \"try-again-button\"]);\n                        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showMessage)(`LEVEL ${this.level.id + 1} COMPLETE!`);\n                    }\n                }\n\n                // Update the time display\n                let currentTime = new Date().getTime();\n                let elapsedTime = currentTime - this.lastStartTime;\n                let timerBar = document.getElementById(\"time-remaining\");\n                let value = Math.ceil(this.timeRemaining - elapsedTime);\n                timerBar.value = value;\n\n                // Check if time has run out\n                if (value <= 0) {\n                    this.running = false;\n                    this.dimmerMaskOn(true);\n                    (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\"end-of-level-display\",\n                        \"end-level-message\",\n                        \"action-replay-button\",\n                        \"try-again-button\"]);\n                    (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"next-level-button\", \"go-button\"]);\n                    (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showMessage)(\"Out of time!\");\n                }\n\n                // Take a snapshot of the game for action replays\n                if (this.frameCount % _constants_js__WEBPACK_IMPORTED_MODULE_4__.REPLAY_SNAPSHOT_FREQUENCY === 0) {\n                    let snapshot = {\n                        dog: {\n                            x: this.dog.xPos,\n                            y: this.dog.yPos,\n                            direction: this.dog.direction\n                        },\n                        sheep: []\n                    };\n                    let sheep;\n                    for (let i = 0; i < this.herd.xArray.length; i++) {\n                        sheep = this.herd.xArray[i];\n                        snapshot.sheep.push({\n                            x: sheep.xPos,\n                            y: sheep.yPos,\n                            direction: sheep.direction,\n                            isLamb: sheep.isLamb\n                        });\n                    }\n                    this.snapshots.push(snapshot);\n                }\n\n                \n            }\n            // Finally, if this is not an action replay, draw the frame\n            if (!this.actionReplay) {\n                (0,_frame_drawer_js__WEBPACK_IMPORTED_MODULE_3__.drawFrame)(this.dog, this.herd, this.frameCount, this.graphics);\n            }\n\n        }\n\n        // Request the next frame, passing the updageGame function as the callback.\n        window.requestAnimationFrame(this.updateGame);\n    }).bind(this);\n\n    this.onGoButtonClicked = function() {\n        this.startGameAgain();\n    };\n\n    /**\n     * Starts the current level again. \n     */\n    this.repeatCurrentLevel = function () {\n        this.startLevel(this.level.id);\n    };\n\n    /**\n     * Starts the next level.\n     */\n    this.startNextLevel = function () {\n        this.startLevel(this.level.id + 1);\n    };\n\n    /**\n     * Begins the game again at level 0 (shown to the player as 1)\n     */\n    this.startGameAgain = function () {\n        this.awaitingGameStart = false;\n        this.startLevel(0);\n    };\n\n    /**\n     * Begin a level\n     * @param {Integer} levelIndex \n     */\n    this.startLevel = function (levelIndex) {\n        this.snapshots = [];\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"end-of-level-display\"]);\n        this.level = _data_levels_js__WEBPACK_IMPORTED_MODULE_2__.levels[levelIndex];\n        this.dog = new _dog_js__WEBPACK_IMPORTED_MODULE_0__.Dog(_constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_WIDTH / 2,\n            _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_HEIGHT / 2,\n            this.level.obstacles);\n\n        // A new dog is created for each level, so the listener for the \n        // dog speed slider in settings must be attached each time\n        this.dog.setSliderEventListener();\n\n        // As with the dog, a new herd is created for each level, and \n        // needs its own event listeners\n        this.herd = new _herd_js__WEBPACK_IMPORTED_MODULE_1__.Herd(this.level);\n        this.herd.setHerdClosenessEventListener();\n        this.herd.setDogScarinessEventListener();\n\n        this.frameCount = 0;\n        let timeAllowedSlider = document.getElementById(\"time-allowed\");\n        this.levelTimeLimit = this.level.time * 1000 * timeAllowedSlider.value;\n        this.timeRemaining = this.level.time * 1000 * timeAllowedSlider.value;\n        this.lastStartTime = new Date().getTime();\n\n        this.running = true;\n    };\n\n    // Clear the contents of the game canvas by drawing over it.\n    this.drawBackground = function () {\n        let image = this.graphics.backgrounds.images[this.level.id];\n        if (image) {\n            let gameCanvas = document.getElementById('game-area');\n            let context = gameCanvas.getContext('2d');\n            context.drawImage(image, 0, 0);\n        } \n    };\n\n    /**\n     * Allows the game to be restarted\n     */\n    this.start = function () {\n        this.running = true;\n        this.lastStartTime = new Date().getTime();\n    };\n\n    /**\n     * Allows the game to be paused\n     */\n    this.stop = function () {\n        this.running = false;\n        let currentTime = new Date().getTime();\n        let timeSinceLastStart = currentTime - this.lastStartTime;\n        this.timeRemaining -= timeSinceLastStart;\n    };\n\n    /**\n     * Begins an action replay of the level just finished\n     */\n    this.startActionReplay = function () {\n        this.dimmerMaskOn(false);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"end-of-level-display\"]);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\"action-replay-display\",\n            \"replay-banner\",\n            \"replay-time\"]);\n        this.actionReplay = new _action_replay_js__WEBPACK_IMPORTED_MODULE_5__.ActionReplay(\n            this.snapshots,\n            this.graphics,\n            this.level);\n    };\n\n    /**\n     * Ends the replay, and presents the player with the choice of\n     * playing the same level again, or going to the next level if the\n     * previous one was completed successfully\n     */\n    this.finishReplay = function () {\n        this.actionReplay = null;\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"action-replay-display\",\n            \"end-level-message\",\n            \"action-replay-button\",\n            \"replay-time\",\n            \"replay-banner\"]);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\"end-of-level-display\"]);\n    };\n\n    this.toStart = function () {\n        if (this.actionReplay) {\n            this.actionReplay.snapshotIndex = 0;\n        }\n    };\n    /**\n     * Sets the speed of the action replay to -1x\n     */\n    this.rewindReplay = function () {\n        if (this.actionReplay) {\n            this.actionReplay.replaySpeed = _action_replay_js__WEBPACK_IMPORTED_MODULE_5__.ReplaySpeed.REWIND;\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\"pause\"]);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"play\"]);\n        }\n    };\n\n    /**\n     * Starts the action replay, playing at 1x\n     */\n    this.playReplay = function () {\n        if (this.actionReplay) {\n            this.actionReplay.replaySpeed = _action_replay_js__WEBPACK_IMPORTED_MODULE_5__.ReplaySpeed.NORMAL;\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\"pause\"]);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"play\"]);\n        }\n    };\n\n    /**\n     * Paused the action replay\n     */\n    this.pauseReplay = function () {\n        if (this.actionReplay) {\n            this.actionReplay.replaySpeed = _action_replay_js__WEBPACK_IMPORTED_MODULE_5__.ReplaySpeed.PAUSE;\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\"play\"]);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"pause\"]);\n        }\n    };\n\n    /**\n     * Plays the action replay at double speed, 2x\n     */\n    this.fastForwardReplay = function () {\n        if (this.actionReplay) {\n            this.actionReplay.replaySpeed = _action_replay_js__WEBPACK_IMPORTED_MODULE_5__.ReplaySpeed.FAST_FORWARD;\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.show)([\"pause\"]);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.hide)([\"play\"]);\n        }\n    };\n\n    /**\n     * Passes the pointer events through to the dog, as long as the game \n     * is running, and not an action replay.\n     * @param {Number} x The position of the pointer on the x-axis\n     * @param {Number} y The position of the pointer on the y-axis\n     */\n    this.onPointerDown = function (x, y) {\n        if (!this.actionReplay) {\n            this.dog.onPointerDown(x, y);\n        }\n        \n    };\n\n    /**\n     * Passes the pointer events through to the dog, as long as the game \n     * is running, and not an action replay.\n     * @param {Number} x The position of the pointer on the x-axis\n     * @param {Number} y The position of the pointer on the y-axis\n     */\n    this.onPointerUp = function (x, y) {\n        if (!this.actionReplay) {\n            this.dog.onPointerUp(x, y);\n        }\n    };\n\n    /**\n     Passes the pointer events through to the dog, as long as the game \n     * is running, and not an action replay.\n     * @param {Number} x The position of the pointer on the x-axis\n     * @param {Number} y The position of the pointer on the y-axis\n     */\n    this.onPointerMove = function (x, y) {\n        if (!this.actionReplay) {\n            this.dog.onPointerMove(x, y);\n        }\n    };\n    /**\n     * Utility method to partially mask the game ui while a choice of \n     * buttons is being displayed to the player\n     * @param {Boolean} bool Whether the mask should be on or off \n     */\n    this.dimmerMaskOn = function (bool) {\n        let dimmerMask = document.getElementById(\"dimmer-mask\");\n        dimmerMask.style.opacity = bool ? 0.5 : 0;\n    };\n}\n\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/game_runner.js?");

/***/ }),

/***/ "./src/assets/js/herd.js":
/*!*******************************!*\
  !*** ./src/assets/js/herd.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Herd\": () => (/* binding */ Herd)\n/* harmony export */ });\n/* harmony import */ var _sheep_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sheep.js */ \"./src/assets/js/sheep.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./src/assets/js/constants.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utilities.js */ \"./src/assets/js/utilities.js\");\n\n   \n\n\nclass Herd {\n    /**\n     * Represents a collection of sheep. It stores its members in two arrays, \n     * a horizontal and a vertical array. These are maintained in sorted order\n     * by x-position and y-position respectively, in order to facilitate quick\n     * lookup of each sheep's nearest neighbours.\n     * \n     * Testing each sheep's distance from each of its neighbours would be \n     * an algorithm with quadratic complexity. Even though the number of sheep is\n     * not large, this is better avoided to allow the class to be reused in an\n     * application which needs more members.\n     * \n     * @param {Integer} numSheep \n     * @param {Number} canvasWidth \n     * @param {Number} canvasHeight \n     */\n    constructor(level) {\n        this.numSheep = level.sheep;\n        this.centerX = 0;\n        this.centerY = 0;\n        this.xArray = [];\n        this.yArray = [];\n        this.allSheepGone = false;\n        this.obstacles = level.obstacles;\n\n        for (let i = 0; i < this.numSheep; i++) {\n            let possibleSpawnPoints = this.getPossibleSpawnPoints(this.numSheep);\n            let isLamb = i % 2 === 0 ? true : false;\n            let newSheep = new _sheep_js__WEBPACK_IMPORTED_MODULE_0__.Sheep(\n                possibleSpawnPoints[i][0], \n                possibleSpawnPoints[i][1], \n                i,\n                isLamb);\n            this.xArray.push(newSheep);\n            this.yArray.push(newSheep);\n        }\n    }\n\n    /**\n     * Called by the GameRunner on each frame, to update each sheep in turn.\n     * \n     * @param {Dog} dog \n     */\n    update(dog) {\n        this.removeDepartedSheep();\n\n        this.sortPositionArrays();\n\n        this.centerX = this.calculateAverageXPosition();\n        this.centerY = this.calculateAverageYPosition();\n\n        for (let sheep of this.xArray) {\n            // Update the sheep, passing a reference to the dog.\n            sheep.update(this.centerX, this.centerY, dog, this.obstacles);\n        }\n    }\n\n    /**\n     * Checks if any sheep in the herd have left the game area via the top of the screen\n     * (where yPos < 0) and if so, removes them.\n     */\n    removeDepartedSheep() { \n        // If sheep has left the field, remove it from the game.\n        this.xArray = this.xArray.filter(sheep => sheep.yPos > 0);\n        this.yArray = this.yArray.filter(sheep => sheep.yPos > 0);\n        if (this.xArray.length === 0) {\n            this.allSheepGone = true;\n        }\n    }\n\n    /**\n     * Calculates the average position on the x-axis of the sheep in xArray\n     * @returns average x position\n     */\n    calculateAverageXPosition() {\n        let total = 0;\n        for(let i = 0; i < this.xArray.length; i++) {\n            total += this.xArray[i].xPos;\n        }\n        return total / this.xArray.length;\n    }\n\n    /**\n     * Calculates the average position on the y-axis of the sheep in yArray\n     * @returns average y position\n     */\n    calculateAverageYPosition() {\n        let total = 0;\n        for(let i = 0; i < this.yArray.length; i++) {\n            total += this.yArray[i].yPos;\n        }\n        return total / this.yArray.length;\n    }\n\n    /**\n     * Sorts the xArray in order of increasing x position of its sheep, and\n     * the yArray in order of increasing y position of its sheep\n     */\n    sortPositionArrays() {\n        this.xArray.sort((sheep1, sheep2) => {\n            return sheep1.xPos - sheep2.xPos;\n        });\n        this.yArray.sort((sheep1, sheep2) => {\n            return sheep1.yPos - sheep2.yPos;\n        });\n    }\n\n    /**\n     * Creates a collection of spawn points for the herd that do not overlap with\n     * any of the obstacles in this level\n     * \n     * @param {Integer} numSheep \n     * @returns an array containing legal spawn points for the sheep\n     */\n    getPossibleSpawnPoints(numSheep) {\n        let array = [];\n        for (let i = 0; i < numSheep; i++) {\n            let randX, randY; \n            do {\n                randX = _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_BORDER + Math.random() * (_constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_WIDTH - 2 * _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_BORDER);\n                randY = _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_BORDER + Math.random() * (_constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_HEIGHT - 2 * _constants_js__WEBPACK_IMPORTED_MODULE_1__.FIELD_BORDER);\n            } while (!this.pointIsValid(randX, randY));\n            array.push([randX, randY]);\n        }\n        return array;\n    }\n\n    /**\n     * Checks if the supplied point overlaps with any of the obstacles in \n     * this level\n     * \n     * @param {Number} x \n     * @param {Number} y \n     * @returns true if the point supplied does not overlap with any obstacles,\n     * false otherwise\n     */\n    pointIsValid(x, y) {\n        for (let ob of this.obstacles) {\n            let rect = new _utilities_js__WEBPACK_IMPORTED_MODULE_2__.Rectangle(ob.x, \n                                     ob.y, \n                                     ob.x + ob.width, \n                                     ob.y + ob.height);\n            if ((0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.rectContainsPoint)(rect, new _utilities_js__WEBPACK_IMPORTED_MODULE_2__.Point(x, y))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Attaches an event (change) listener to the herd-closeness slider in settings, \n     * to enable the player to experiment with different values for the\n     * minDistanceFromHerd variable\n     */\n     setHerdClosenessEventListener() {\n        let slider = document.getElementById(\"herd-closeness\");\n\n        // Read the current value of the slider and set the variable accordingly\n        this.minDistanceFromHerd = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHEEP_MIN_DISTANCE_FROM_HERD / slider.value;\n\n        // Attach the listener\n        slider.addEventListener('change', () => {\n            // The default is divided by the slider value, as it makes more\n            // intuitive sense for increasing closeness to be the right-hand\n            // end of the slider\n            for (let sheep of this.xArray) {\n                sheep.minDistanceFromHerd = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHEEP_MIN_DISTANCE_FROM_HERD / slider.value;\n            }\n        });\n    }\n\n    /**\n     * Attaches an event (change) listener to the dog-scariness slider in settings, \n     * to enable the player to experiment with different values for the \n     * outerReactionLimit variable\n     */\n    setDogScarinessEventListener() {\n        let slider = document.getElementById(\"dog-scariness\");\n\n        // Read the current value of the slider and set the variable accordingly\n        this.outerReactionLimit = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHEEP_OUTER_REACTION_LIMIT * slider.value;\n\n        // Attach the listener\n        slider.addEventListener('change', () => {\n            for (let sheep of this.xArray) {\n                sheep.outerReactionLimit = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SHEEP_OUTER_REACTION_LIMIT * slider.value;\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/herd.js?");

/***/ }),

/***/ "./src/assets/js/index.js":
/*!********************************!*\
  !*** ./src/assets/js/index.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dog.js */ \"./src/assets/js/dog.js\");\n/* harmony import */ var _herd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./herd.js */ \"./src/assets/js/herd.js\");\n/* harmony import */ var _game_runner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game_runner.js */ \"./src/assets/js/game_runner.js\");\n/* harmony import */ var _data_levels_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/levels.js */ \"./src/assets/data/levels.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"./src/assets/js/constants.js\");\n\n\n\n\n\n\n// Wait for all content to be loaded into the DOM before performing setup.\ndocument.addEventListener('DOMContentLoaded', function () {\n    init();\n});\n\n/**\n * Executes the startup tasks - \n *  1) Create a graphics object to hold the graphics urls and images\n *  2) Create the main game objects - gameRunner, dog and herd\n *  3) Add event listeners to the canvas for click and drag events\n *  4) Add event listeners to the end-of-level buttons\n *  5) Add event listeners to the action-replay control buttons\n *  6) Load the images asynchronously\n *  7) Call window.requestAnimationFrame() to begin drawing the game\n */\nfunction init () {\n    let gameCanvas = document.getElementById('game-area');\n    gameCanvas.width = _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_WIDTH;\n    gameCanvas.height = _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_HEIGHT;\n\n    /* \n        The graphics used by the game consist of 2 characters (dog and sheep)\n        and a unique background for each level. Each character has four possible \n        directions in which it can face, and three animation frames for each\n        direction:\n            1) left leg forward\n            2) right leg forward\n            3) legs together,\n        making 12 sprites in total.\n    */\n    let graphics = {\n        dog: {\n            urls: [\n                'dog_south_left', 'dog_south_right', 'dog_south_center',\n                'dog_west_left', 'dog_west_right', 'dog_west_center',\n                'dog_north_left', 'dog_north_right', 'dog_north_center',\n                'dog_east_left', 'dog_east_right', 'dog_east_center'\n            ],\n            images: [],\n        },\n        sheep: {\n            urls: [\n                'sheep_south_left', 'sheep_south_right', 'sheep_south_center',\n                'sheep_west_left', 'sheep_west_right', 'sheep_west_center',\n                'sheep_north_left', 'sheep_north_right', 'sheep_north_center',\n                'sheep_east_left', 'sheep_east_right', 'sheep_east_center'\n            ],\n            images: []\n        },\n        backgrounds: {\n            urls: ['level1', 'level2', 'level3'],\n            images: [],\n        }\n    };\n\n    // Create the main game objects\n    let level = _data_levels_js__WEBPACK_IMPORTED_MODULE_3__.levels[0];\n    let gameRunner = new _game_runner_js__WEBPACK_IMPORTED_MODULE_2__.GameRunner(graphics, level);\n\n    // Add event listeners to the game canvas, to enable the player to \n    // control the dog\n    gameCanvas.addEventListener('pointerdown', (event) => {\n        let rect = gameCanvas.getBoundingClientRect();\n        let x = (event.clientX - rect.left) / rect.width * _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_WIDTH;\n        let y = (event.clientY - rect.top) / rect.height * _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_HEIGHT;\n        gameRunner.onPointerDown(x, y);\n    });\n\n    gameCanvas.addEventListener('pointerup', (event) => {\n        let rect = gameCanvas.getBoundingClientRect();\n        let x = (event.clientX - rect.left) / rect.width * _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_WIDTH;\n        let y = (event.clientY - rect.top) / rect.height * _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_HEIGHT;\n        gameRunner.onPointerUp(x, y);\n    });\n\n    gameCanvas.addEventListener('pointermove', event => {\n        if (gameRunner.frameCount % 2 === 0){ // throttle the mouse events\n            let rect = gameCanvas.getBoundingClientRect();\n            let x = (event.clientX - rect.left) / rect.width * _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_WIDTH;\n            let y = (event.clientY - rect.top) / rect.height * _constants_js__WEBPACK_IMPORTED_MODULE_4__.FIELD_HEIGHT;\n            gameRunner.onPointerMove(x, y);\n        }\n    });\n\n    //  Prevents a touch (mobile only) on the gameCanvas from scrolling\n    //  the entire view\n    gameCanvas.addEventListener('touchmove', event => {\n        event.preventDefault();\n    });\n\n    // Add event listeners to the buttons displayed at the start of the game, \n    // and at the end of each level. The event listener is just added to the DOM\n    // here, and the event handling is delegated to the gameRunner object\n    document.getElementById(\"go-button\").addEventListener('click', event => {\n        gameRunner.dimmerMaskOn(false);\n        gameRunner.onGoButtonClicked();\n    });\n\n    // There are two different buttons to launch the instructions - one at the\n    // top of the screen and one in the end-of-level display, only shown \n    // between levels\n    let array = document.getElementsByClassName(\"instructions-button\");\n    for (let button of array) {\n        button.addEventListener('click', () => {\n            document.getElementById(\"instructions-modal\").style.display = \"initial\";\n            gameRunner.stop();\n        });\n    }\n    \n    document.getElementById(\"close-instructions-button\").addEventListener('click', () => {\n        document.getElementsByClassName(\"modal\")[0].style.display = \"none\";   \n        if (!gameRunner.awaitingGameStart) {\n            gameRunner.start();     \n        }\n    });\n\n    document.getElementById(\"settings-top-button\").addEventListener('click', () => {\n        document.getElementById(\"settings-modal\").style.display = \"initial\";\n        gameRunner.stop();\n    });\n\n    document.getElementById(\"close-settings-button\").addEventListener('click', () => {\n        document.getElementById(\"settings-modal\").style.display = \"none\";\n        if (!gameRunner.awaitingGameStart) {\n            gameRunner.start();     \n        }\n    });\n\n    document.getElementById(\"next-level-button\").addEventListener('click', event => {\n        gameRunner.dimmerMaskOn(false);\n        gameRunner.startNextLevel();\n    });\n\n    document.getElementById(\"try-again-button\").addEventListener('click', event => {\n        gameRunner.dimmerMaskOn(false);\n        gameRunner.repeatCurrentLevel();\n    });\n\n    document.getElementById(\"action-replay-button\").addEventListener('click', event => {\n        gameRunner.dimmerMaskOn(false);\n        gameRunner.startActionReplay();\n    });\n\n    document.getElementById(\"begin-again-button\").addEventListener('click', event => {\n        gameRunner.dimmerMaskOn(false);\n        gameRunner.startGameAgain();\n    });\n\n\n    // Add event listeners to the buttons used to control the action replay. Event\n    // handling here is delegated to the gameRunner object\n    document.getElementById(\"to-start\").addEventListener('click', event => {\n        gameRunner.toStart();\n    });\n\n    document.getElementById(\"rewind\").addEventListener('click', event => {\n        gameRunner.rewindReplay();\n    });\n\n    document.getElementById(\"play\").addEventListener('click', event => {\n        gameRunner.playReplay();\n    });\n\n    document.getElementById(\"pause\").addEventListener('click', event => {\n        gameRunner.pauseReplay();\n    });\n\n    document.getElementById(\"fast-forward\").addEventListener('click', event => {\n        gameRunner.fastForwardReplay();\n    });\n\n    document.getElementById(\"finish\").addEventListener('click', event => {\n        gameRunner.finishReplay();\n    });\n\n    // Finally, call the async function loadAllImages, and when the images\n    // have all loaded successfully, make the first call to request an \n    // animation frame and begin the game drawing loop.\n    loadAllImages(graphics).then(() => {\n        window.requestAnimationFrame(gameRunner.updateGame);\n    });\n}\n\n// This async function creates a Promise per image, and adds it to an array.\n// Promise.all() is invoked to await resolution of all the promises\nasync function loadAllImages (graphics) {\n    let promiseArray = [];\n\n    // Create promises for loading of sheep images\n    for (let url of graphics.dog.urls) {\n        promiseArray.push(new Promise(resolve => {\n            const img = new Image();\n            img.src = `src/assets/images/dog_images/${url}.png`;\n            graphics.dog.images.push(img);\n            img.addEventListener('load', () => {\n                resolve();\n            });\n        }));\n    }\n\n    // Create promises for loading of sheep images\n    for (let url of graphics.sheep.urls) {\n        promiseArray.push(new Promise(resolve => {\n            const img = new Image();\n            img.src = `src/assets/images/sheep_images/${url}.png`;\n            graphics.sheep.images.push(img);\n            img.addEventListener('load', () => {\n                resolve();\n            });\n        }));\n    }\n\n    // Create promises for loading of level background images\n    for (let url of graphics.backgrounds.urls) {\n        promiseArray.push(new Promise(resolve => {\n            const img = new Image();\n            img.src = `src/assets/images/backgrounds/${url}.png`;\n            graphics.backgrounds.images.push(img);\n            img.addEventListener('load', () => {\n                resolve();\n            });\n        }));\n    }\n\n    // Wait for all promises to resolve\n    await Promise.all(promiseArray);\n}\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/index.js?");

/***/ }),

/***/ "./src/assets/js/sheep.js":
/*!********************************!*\
  !*** ./src/assets/js/sheep.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sheep\": () => (/* binding */ Sheep)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/assets/js/constants.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities.js */ \"./src/assets/js/utilities.js\");\n\n\n\n\nclass Sheep {\n    /**\n     * Represents a sheep, with a velocity and direction. The sheep also\n     * has an anxiety field, which affects how the sheep reacts to the\n     * dog and the other members of its herd.\n     * \n     * @param {Number} xPos \n     * @param {Number} yPos \n     */\n    constructor(xPos, yPos, id, isLamb) {\n        this.xPos = xPos;\n        this.yPos = yPos;\n        this.direction = -Math.PI + Math.random() * Math.PI;\n        this.velocity = 0;\n        this.id = id;\n        this.moving = false;\n        this.isLamb = isLamb;\n        this.minDistanceFromHerd = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHEEP_MIN_DISTANCE_FROM_HERD;\n        this.outerReactionLimit = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHEEP_OUTER_REACTION_LIMIT;\n        \n    }\n\n    /**\n     * Updates the sheep's attributes based on the location of the dog, and of\n     * the location of the center of the herd.\n     * \n     * @param {Number} herdXCenter \n     * @param {Number} herdYCenter \n     * @param {Dog} dog \n     */\n    update(herdXCenter, herdYCenter, dog, obstacles) {\n\n        // Calculate the sheeps velocity towards the center of the herd\n        let xHerdVel, yHerdVel;\n        [xHerdVel, yHerdVel] = this.getVelocityTowardHerd(herdXCenter, herdYCenter);\n\n        // Calculate the sheeps velocity away from the dog.\n        let xDogVel, yDogVel;\n        [xDogVel, yDogVel] = this.getVelocityAwayFromDog(dog);\n\n        // Check if the sheep is too close to any side, and if so, give it a \n        // velocity in the opposite direction\n        let xSideVel, ySideVel;\n        [xSideVel, ySideVel] = this.getVelocityAwayFromSides();\n\n        // Sum the velocities and update the sheeps position\n        let combinedXVel = xHerdVel + xDogVel + xSideVel;\n        let combinedYVel = yHerdVel + yDogVel + ySideVel;\n        if (Math.abs(combinedXVel) <= 1 && Math.abs(combinedYVel) <= 1) {\n            // Don't move the sheep if the net movement calculated is very small\n            this.moving = false;\n            this.direction = Math.atan2(combinedYVel, combinedXVel);\n            combinedXVel = 0;\n            combinedYVel = 0;\n        } else {\n            this.moving = true;\n            this.direction = Math.atan2(combinedYVel, combinedXVel);\n        }\n\n        // Ensure the calculated move will not result in the sheep entering\n        // any of the obstacles in this level\n        [combinedXVel, combinedYVel] = this.checkMoveForObstacles(\n            combinedXVel,\n            combinedYVel,\n            obstacles);\n\n        // Update the sheep's position\n        this.xPos += combinedXVel;\n        this.yPos += combinedYVel;\n\n        // Ensure the sheep has not left the game area\n        this.checkGameAreaBounds();\n    }\n\n    /**\n     * Calculates the sheeps velocity toward the center of the herd, \n     * based on the herd's position and the anxiety level of the sheep.\n     * \n     * @param {Number} herdXCenter \n     * @param {Number} herdYCenter \n     * @returns an array containing the x and y velocity components.\n     */\n    getVelocityTowardHerd(herdXCenter, herdYCenter) {\n        let distToHerd = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.getDistanceToPoint)(this.xPos, this.yPos, herdXCenter, herdYCenter);\n        if (distToHerd > this.minDistanceFromHerd) {\n            let directionToHerdCenter = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.getDirectionToPoint)(\n                this.xPos,\n                this.yPos,\n                herdXCenter,\n                herdYCenter);\n\n            let velocity = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHEEP_VELOCITY_TOWARDS_HERD;\n            return [velocity * Math.cos(directionToHerdCenter),\n            velocity * Math.sin(directionToHerdCenter)];\n        } else {\n            return [0, 0];\n        }\n    }\n\n    /**\n     * Calculates the sheep's velocity away from the dog. The sheep is indifferent\n     * to the dog outside of the range SHEEP_OUTER_REACTION_LIMIT, and its velocity away\n     * from the dog is proportional to its distance within that range, up to a limit\n     * of SHEEP_MAX_VELOCITY_AWAY_FROM_DOG\n     * \n     * @param {Dog} dog \n     * @returns an array containing the x and y velocity components.\n     */\n    getVelocityAwayFromDog(dog) {\n        let reactionRange = this.outerReactionLimit;\n        let xVel = 0;\n        let yVel = 0;\n\n        // Compare the squares of the distances (it's not necessary to compute the\n        // square root also before deciding if the dog is within range - that's \n        // an expensive operation).\n        let dogXDistSq = Math.pow(dog.xPos - this.xPos, 2);\n        let dogYDistSq = Math.pow(dog.yPos - this.yPos, 2);\n        if (dogXDistSq + dogYDistSq < Math.pow(reactionRange, 2)) {\n\n            // The sheep is within reaction range. Its speed away from the dog depends\n            // on how far away it is, hitting a maximum if the dog is within 30.\n            let dist = Math.sqrt(dogXDistSq + dogYDistSq);\n\n            // The sheep moves away at a speed proportional to the dogs closeness.\n            let multiplier = this.outerReactionLimit / dist;\n            let velocity = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHEEP_BASE_VELOCITY_AWAY_FROM_DOG * multiplier;\n            if (velocity > _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHEEP_MAX_VELOCITY_AWAY_FROM_DOG) {\n                velocity = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHEEP_MAX_VELOCITY_AWAY_FROM_DOG;\n            }\n            let angle = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.getDirectionToPoint)(this.xPos, this.yPos, dog.xPos, dog.yPos);\n            // Reverse the angle so that the sheep moves away.\n            angle = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.ensureCorrectRange)(angle + Math.PI);\n            xVel = Math.cos(angle) * velocity;\n            yVel = Math.sin(angle) * velocity;\n        }\n        return [xVel, yVel];\n    }\n\n    /**\n     * Checks if this sheep is too close to the side of the game area, and if so, \n     * gives it a velocity away from that side. This helps to prevent the sheep from\n     * becoming trapped in the corners.\n     * @returns an array containing an x- and y-component of velocity\n     */\n    getVelocityAwayFromSides() {\n        // The direction vector will be multiplied by the velocity to produce\n        // the x and y components\n        let direction = [0, 0];\n        let dist;\n        if (this.xPos < _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIDE_REPULSION_DISTANCE) {\n            direction = [1, 0];\n            dist = this.xPos;\n        } else if (this.xPos > _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_WIDTH - _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIDE_REPULSION_DISTANCE) {\n            direction = [-1, 0];\n            dist = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_WIDTH - this.xPos;\n        } else if (this.yPos < _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIDE_REPULSION_DISTANCE) {\n            // The sheep is at the top of the game area - we must not prevent\n            // it from leaving through the exit. Only create a velocity away from \n            // the top side if the sheep is not in front of the exit\n            if (this.xPos < 165 || this.xPos > 235) {\n                direction = [0, 1];\n                dist = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIDE_REPULSION_DISTANCE;\n            }\n        } else if (this.yPos > _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_HEIGHT - _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIDE_REPULSION_DISTANCE) {\n            direction = [0, -1];\n            dist = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_HEIGHT - this.yPos;\n        }\n        \n        // Let's make the velocity inversely proportional to the distance from the wall\n        let multiplier;\n        if (dist > 0) {\n            multiplier = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIDE_REPULSION_DISTANCE / dist;\n        } else {\n            multiplier = 1;\n        }\n        let velocity = _constants_js__WEBPACK_IMPORTED_MODULE_0__.SHEEP_BASE_VELOCITY_AWAY_FROM_DOG * multiplier;\n\n        // Use the direction vector assigned in the if statements above to calculate the\n        // correct x- and y- components for the velocity\n        let xComponent = direction[0] * velocity;\n        let yComponent = direction[1] * velocity;\n        return [xComponent, yComponent];\n    }\n\n    /**\n     * Checks if the sheep has left the game-area, and unless it has left via the gate, \n     * returns it to the edge of the game-area again.\n     */\n    checkGameAreaBounds() {\n        if (this.xPos < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_BORDER) {\n            this.xPos = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_BORDER;\n        } else if (this.xPos > _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_WIDTH - _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_BORDER) {\n            this.xPos = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_WIDTH - _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_BORDER;\n        }\n        if (this.yPos < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_BORDER && (this.xPos < 165 || this.xPos > 235)) {\n            this.yPos = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_BORDER;\n        } else if (this.yPos > _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_HEIGHT - _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_BORDER) {\n            this.yPos = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_HEIGHT - _constants_js__WEBPACK_IMPORTED_MODULE_0__.FIELD_BORDER;\n        }\n    }\n\n    /**\n     * Ensures that the sheep does not enter an area of the level occupied by \n     * an obstacle.\n     * @param {Number} xVel The x velocity calculated for the current move\n     * @param {Number} yVel The y velocity calculated for the current move\n     * @returns the x and y velocities adjusted to avoid entering an obstacle\n     */\n    checkMoveForObstacles(xVel, yVel, obstacles) {\n        let futureX = this.xPos + xVel;\n        let futureY = this.yPos + yVel;\n        for (let obstacle of obstacles) {\n            let rect = new _utilities_js__WEBPACK_IMPORTED_MODULE_1__.Rectangle(\n                obstacle.x,\n                obstacle.y,\n                obstacle.x + obstacle.width,\n                obstacle.y + obstacle.height);\n            if ((0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.rectContainsPoint)(rect, new _utilities_js__WEBPACK_IMPORTED_MODULE_1__.Point(futureX, futureY))) {\n                // Try keeping the current xPosition unchanged\n                if (!(0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.rectContainsPoint)(rect, new _utilities_js__WEBPACK_IMPORTED_MODULE_1__.Point(this.xPos, futureY))) {\n                    return [0, yVel];\n                }\n                // If that doesn't work, try keeping the current yPosition unchanged\n                if (!(0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.rectContainsPoint)(rect, new _utilities_js__WEBPACK_IMPORTED_MODULE_1__.Point(futureX, this.yPos))) {\n                    return [yVel, 0];\n                }\n                // Last resort, keep both unchanged\n                return [0, 0];\n\n            }\n        }\n        return [xVel, yVel];\n    }\n}\n\n\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/sheep.js?");

/***/ }),

/***/ "./src/assets/js/utilities.js":
/*!************************************!*\
  !*** ./src/assets/js/utilities.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Point\": () => (/* binding */ Point),\n/* harmony export */   \"Quadrant\": () => (/* binding */ Quadrant),\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle),\n/* harmony export */   \"ensureCorrectRange\": () => (/* binding */ ensureCorrectRange),\n/* harmony export */   \"getAngularDifference\": () => (/* binding */ getAngularDifference),\n/* harmony export */   \"getDirectionToPoint\": () => (/* binding */ getDirectionToPoint),\n/* harmony export */   \"getDistanceToPoint\": () => (/* binding */ getDistanceToPoint),\n/* harmony export */   \"getQuadrant\": () => (/* binding */ getQuadrant),\n/* harmony export */   \"hide\": () => (/* binding */ hide),\n/* harmony export */   \"rectContainsPoint\": () => (/* binding */ rectContainsPoint),\n/* harmony export */   \"show\": () => (/* binding */ show),\n/* harmony export */   \"showMessage\": () => (/* binding */ showMessage)\n/* harmony export */ });\n/**\n * Gets the difference between the two angles provided in radians.\n * Adjusts for the discontinuity when the angles are on either side\n * of the negative x-axis, i.e. when one is between -PI/2 and -PI \n * and the other is between PI/2 and PI.\n * @param {Number} angleFrom in radians\n * @param {Number} angleTo in radians\n * @returns the difference between the parameters in radians\n */\nfunction getAngularDifference (angleTo, angleFrom) {\n    let difference = angleTo - angleFrom;\n    if (difference > Math.PI) {\n        difference -= 2 * Math.PI;\n    }\n    if (difference < -Math.PI) {\n        difference += 2 * Math.PI;\n    }\n    return difference;\n}\n\n/**\n * Calculates the direction a game object should travel in to reach\n * the point (xTo, yTo) from its current position(xFrom, yFrom)\n * \n * @param {Number} xFrom \n * @param {Number} yFrom \n * @param {Number} xTo \n * @param {Number} yTo \n * @returns A direction (angle) such that -Math.PI <= angle <= Math.PI\n */\nfunction getDirectionToPoint (xFrom, yFrom, xTo, yTo) {\n    return Math.atan2(yTo - yFrom, xTo - xFrom);\n}\n\n/**\n * Calculates the distance between 2 points.\n * @param {Number} x1 \n * @param {Number} y1 \n * @param {Number} x2 \n * @param {Number} y2 \n * @returns The distance between (x1, y1) and (x2, y2)\n */\nfunction getDistanceToPoint (x1, y1, x2, y2) {\n    let xDistSq = Math.pow(x2 - x1, 2);\n    let yDistSq = Math.pow(y2 - y1, 2);\n    return Math.sqrt(xDistSq + yDistSq);\n}\n\nconst Quadrant = {\n    EAST: {\n        name: \"east\",\n        min: -Math.PI * 0.25,\n        max: Math.PI * 0.25\n    },\n    SOUTH: {\n        name: \"south\",\n        min: Math.PI * 0.25,\n        max: Math.PI * 0.75,\n    },\n    NORTH: {\n        name: \"north\",\n        min: -Math.PI * 0.75,\n        max: -Math.PI * 0.25\n    },\n    WEST: {\n        name: \"west\",\n        min: Math.PI * 0.75,\n        max: -Math.PI * 0.75\n    }\n};\n\nfunction getQuadrant (angle) {\n    if (angle >= Quadrant.EAST.min && angle < Quadrant.EAST.max) {\n        return Quadrant.EAST;\n    } else if (angle >= Quadrant.SOUTH.min && angle < Quadrant.SOUTH.max) {\n        return Quadrant.SOUTH;\n    } else if (angle >= Quadrant.NORTH.min && angle < Quadrant.NORTH.max) {\n        return Quadrant.NORTH;\n    } else {\n        return Quadrant.WEST;\n    }\n}\n\n/**\n * Returns a value between -Math.PI and Math.PI, by recursively adding or subtracting\n * Math.PI (depending on whether the angle is below or above the range).\n * @param {Number} angle \n * @returns \n */\nfunction ensureCorrectRange (angle) {\n    if (angle > Math.PI) {\n        return ensureCorrectRange(angle - Math.PI * 2);\n    } else if (angle < -Math.PI) {\n        return ensureCorrectRange(angle + Math.PI * 2);\n    } else {\n        return angle;\n    }\n}\n\n/**\n * Tests if the point supplied is within the rectangle supplied.\n * @param {Rectangle} rect \n * @param {Point} point \n * @returns true if the point is contained within the rectangle\n */\nfunction rectContainsPoint (rect, point) {\n    let isContained = true;\n    if (point.x > rect.right || point.x < rect.left) {\n        isContained = false;\n    }\n    if (point.y > rect.bottom || point.y < rect.top) {\n        isContained = false;\n    }\n    return isContained;\n}\n\n/**\n * A class representing a point\n */\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\n/**\n * A class representing a rectangle\n */\nclass Rectangle {\n    constructor(left, top, right, bottom) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n}\n\n/**\n     * Utility method to display an array of HTML elements.\n     * @param {Array} array of HTML id attributes \n     */\nfunction show (array) {\n    for (let i = 0; i < array.length; i++) {\n        document.getElementById(array[i]).style.display = \"initial\";\n    }\n}\n\n/**\n * Utility method to display an array of HTML elements.\n * @param {Array} array of HTML id attributes \n */\nfunction hide (array) {\n    for (let i = 0; i < array.length; i++) {\n        document.getElementById(array[i]).style.display = \"none\";\n    }\n}\n\n/**\n * Utility method to show a string to the player\n * @param {String} message to be displayed\n */\nfunction showMessage (message) {\n    let displayText = document.getElementById(\"end-level-message\");\n    displayText.innerText = message;\n}\n\n//# sourceURL=webpack://doggone-it/./src/assets/js/utilities.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/assets/js/index.js");
/******/ 	
/******/ })()
;